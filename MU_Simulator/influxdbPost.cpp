// This code is for testing the online pcap data POST to Influxdb
// using the socket programming, few parameters write

#include <pcap.h>
#include <errno.h>
#include <time.h>
#include <stdio.h>
#include <limits.h>
#include <stdint.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/ether.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

struct sv_header {
    unsigned char d_host[6];
    unsigned char s_host[6];
    unsigned short int ether_type;
    unsigned short int appid;
    unsigned short int length;
    unsigned short int reserved1;
    unsigned short int reserved2;
    unsigned short int sav_pdu_id:8,sav_pdu_len:8;
    unsigned char no_asdu_id;
    unsigned short int no_asdu_num:8,no_asdu_num2:8;
    unsigned short int seq_asdu:8,asdu_len:8;
    unsigned short int seq_asdu1:8,asdu1_len:8;
    unsigned short int svID_id:8,svID_len:8;
    char svID[20];
    unsigned short int smp_count_id;
    unsigned short int smp_count;
    unsigned short int conf_rev_id;
    unsigned int conf_rev;
    unsigned short int smp_synch_id;
    unsigned char smp_synch;
    unsigned short int seq_data_id:8,data_len:8;    
};

struct analog {
    
    int32_t ia;
    unsigned int ia_q;
    int32_t ib;
    unsigned int ib_q;
    int32_t ic;
    unsigned int ic_q;
    int32_t in;
    unsigned int in_q;
    int32_t va;
    unsigned int va_q;
    int32_t vb;
    unsigned int vb_q;
    int32_t vc;
    unsigned int vc_q;
    int32_t vn;
    unsigned int vn_q;
};


#define PORT        8086        /* Port number as an integer - web server default is 80 */
#define IP_ADDRESS "127.0.0.1"    /* IP Address as a string */
#define BUCKET "test"
#define ORG "ge"
#define TOKEN "EsLLWa0AiMiKnmLBycRF2IBN4mzxdv2Hfi81lqqYi9cpvgQC8xeTbN0fPCi9dtuBq9UIq1v4NsCqAw6QQ2gZoQ=="

#define MEASURE "61850_SV"

#define BUFSIZE 8196


void got_packet(u_char *args, const struct pcap_pkthdr *, const u_char *);

int main(int argc, char **argv)
{
	char *device = argv[1];
	char errbuf[PCAP_ERRBUF_SIZE];
	pcap_t *p;
    int snaplen=130;
    int to_ms=1000;
    int promisc = 1;
    bpf_u_int32 net;
	bpf_u_int32 mask;
	struct bpf_program fp;
    char flt_exp[]="ether proto 0x88BA";
    int optimize = 1;
    pcap_dumper_t *pd;
    int count = -1;
       
    int i;        
	
	if (!(p = pcap_open_live(device, snaplen, promisc, to_ms, errbuf))) 
        {
            fprintf(stderr, "Error opening interface %s: %s\n", device, errbuf);
            exit(2);
        }
	 if (pcap_lookupnet(device, &net, &mask, errbuf) < 0) 
        {
            fprintf(stderr, "Error looking up network: %s\n", errbuf);
            exit(3);
        }
    if (pcap_compile(p,&fp,flt_exp,optimize,mask) < 0) 
        {
                /*
                 * Print out appropriate text, followed by the error message
                 * generated by the packet capture library.
                 */
                fprintf(stderr, "Error compiling bpf filter on %s: %s\n",
                        device, pcap_geterr(p));
                exit(4);
        }
	if (pcap_setfilter(p, &fp) < 0) 
        {
                exit(5);
        }
	if (pcap_loop(p, count, &got_packet,NULL) < 0) {
                /*
                 * Print out appropriate text, followed by the error message
                 * generated by the packet capture library.
                 */
                exit(6);
        }

    pcap_freecode(&fp);
	pcap_close(p);
return 0;
}

void got_packet(u_char *args, const struct pcap_pkthdr *phdr, const u_char *packet)
{
	int sockfd;
    int loop;
    int ret;
    char header[BUFSIZE];
    char body[BUFSIZE];
    char result[BUFSIZE];
    static struct sockaddr_in serv_addr; /* static is zero filled on start up */
    struct sv_header* svph= (struct sv_header *)(packet); 
    struct analog* measure= (struct analog *)(packet+sizeof(sv_header)-3);
    printf("Connecting socket to %s and port %d\n", IP_ADDRESS, PORT);
    sockfd = socket(AF_INET, SOCK_STREAM,0);
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = inet_addr(IP_ADDRESS);
    serv_addr.sin_port = htons(PORT);
    connect(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr));
    sprintf(body, "%s,svID=%.20s smpCount=%d,IA=%d,IAQ=%d,IB=%d,IBQ=%d,IC=%d,ICQ=%d,IN=%d,INQ=%d,VA=%d,VAQ=%d,VB=%d,VBQ=%d,VC=%d,VCQ=%d,VN=%d,VNQ=%d   \n", MEASURE,svph->svID,ntohs(svph->smp_count),ntohl(measure->ia),ntohl(measure->ia_q),ntohl(measure->ib),ntohl(measure->ib_q),ntohl(measure->ic),ntohl(measure->ic_q),ntohl(measure->in),ntohl(measure->in_q),ntohl(measure->va),ntohl(measure->va_q),ntohl(measure->vb),ntohl(measure->vb_q),ntohl(measure->vc),ntohl(measure->vc_q),ntohl(measure->vn),ntohl(measure->vn_q));
    sprintf(header,"POST /api/v2/write?org=%s&bucket=%s&precision=ns HTTP/1.1\r\nHost: influx:8086\r\nAuthorization:Token %s\r\nContent-Length: %ld\r\n\r\n", 
             ORG, BUCKET, TOKEN, strlen(body)); 

    printf("Send to InfluxDB the POST request bytes=%d \n->|%s|<-\n",strlen(header), header);
    write(sockfd, header, strlen(header));
    printf("Send to InfluxDB the data bytes=%d \n->|%s|<-\n",strlen(body), body);
    ret = write(sockfd, body, strlen(body));
    
    printf("%d",ret);

    return ;
}
