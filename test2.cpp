// This is the final code to post SV parsed values to Influxdb via REST API post, using sockets

#include <pcap.h> //packet capture library
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <time.h> // to unpack the pcap pkthdr time stamp field ts.tv_sec
#include <sstream> // for the SQLite3 Query, we are creating a string stream containing the query 
#include <string.h>
#include <iostream>
#include <limits.h>
#include <stdint.h> // to support int32_t declrarations
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/ether.h> // to ethernet header stucture (MAC Address)
#include <unistd.h>  /*Write command related header file*/
#include <chrono>

#define BUFSIZE 8196
#define MEASURE "SV"
#define PORT        8086        /* Port number as an integer - web server default is 80 */
#define IP_ADDRESS "10.12.1.93"    /* IP Address of InfluxDB host as a string */
#define BUCKET "test_bucket"
#define ORG "iitr"
#define TOKEN "UdgSohtQiliNJPnkWYOJcWuLdCan8x2YVPMREQaiUxmP0HrJjVDHhH-3aqdAlW30dipN1yJndm7Bidm-Wo9zYg=="


struct sv_header {
    unsigned char d_host[6];
    unsigned char s_host[6];
    unsigned short int ether_type;
    unsigned short int appid;
    unsigned short int length;
    unsigned short int reserved1;
    unsigned short int reserved2;
    unsigned short int sav_pdu_id:8,sav_pdu_len:8;
    unsigned char no_asdu_id;
    unsigned short int no_asdu_num:8,no_asdu_num2:8;
    unsigned short int seq_asdu:8,asdu_len:8;
    unsigned short int seq_asdu1:8,asdu1_len:8;
    unsigned short int svID_id:8,svID_len:8;
    char svID[17];
    unsigned short int smp_count_id;
    unsigned short int smp_count;
    unsigned short int conf_rev_id;
    unsigned int conf_rev;
    unsigned short int smp_synch_id;
    uint8_t smp_synch;
    unsigned short int seq_data_id:8,data_len:8;    
};

struct analog {
    
    int32_t ia;
    unsigned int ia_q;
    int32_t ib;
    unsigned int ib_q;
    int32_t ic;
    unsigned int ic_q;
    int32_t in;
    unsigned int in_q;
    int32_t va;
    unsigned int va_q;
    int32_t vb;
    unsigned int vb_q;
    int32_t vc;
    unsigned int vc_q;
    int32_t vn;
    unsigned int vn_q;
};

void got_packet(u_char *args, const struct pcap_pkthdr *, const u_char *);

int main(int argc, char **argv)
{
    char *device;
    pcap_if_t *alldevsp;
    char errbuf[PCAP_ERRBUF_SIZE];
    pcap_t *p;
    int snaplen=130;
    int to_ms=1000;
    int promisc = 0;
    bpf_u_int32 net;
    bpf_u_int32 mask;
    struct bpf_program fp;
    char flt_exp[]="ether proto 0x88BA";//we are keeping filter at ethe type level, 88BA is for SV
    int optimize = 1;
    int count = -1;
    
     if (!(device = pcap_lookupdev(errbuf))) 
        {
            fprintf(stderr, "Error getting device on system: %s\n", errbuf);
            exit(1);
        }	
	if (!(p = pcap_open_live(device, snaplen, promisc, to_ms, errbuf))) 
        {
            fprintf(stderr, "Error opening interface %s: %s\n", device, errbuf);
            exit(2);
        }
	 if (pcap_lookupnet(device, &net, &mask, errbuf) < 0) 
        {
            fprintf(stderr, "Error looking up network: %s\n", errbuf);
            exit(3);
        }
    if (pcap_compile(p,&fp,flt_exp,optimize,mask) < 0) 
    {
        /*
        * Print out appropriate text, followed by the error message
        * generated by the packet capture library.
        */
        fprintf(stderr, "Error compiling bpf filter on %s: %s\n",
                device, pcap_geterr(p));
        exit(4);
    }
    if (pcap_setfilter(p, &fp) < 0) 
    {
        exit(5);
    }
    if (pcap_loop(p, count, &got_packet,NULL) < 0) {
        /*
        * Print out appropriate text, followed by the error message
        * generated by the packet capture library.
        */
        exit(6);
    }

    pcap_freecode(&fp);
    pcap_close(p);
return 0;
}

void got_packet(u_char *args, const struct pcap_pkthdr *phdr, const u_char *packet)
{
    struct sv_header* svph= (struct sv_header *)(packet); 
    struct analog* measure= (struct analog *)(packet+sizeof(sv_header)-3);
    int sockfd;
    int ret;
    static struct sockaddr_in serv_addr; /* static is zero filled on start up */
    unsigned long result;
    sockfd = socket(AF_INET, SOCK_STREAM,0);
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = inet_addr(IP_ADDRESS);
    serv_addr.sin_port = htons(PORT);
    connect(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr));
    char body[BUFSIZE];
    char header[BUFSIZE];
    std::chrono::nanoseconds ns = std::chrono::high_resolution_clock::now().time_since_epoch();
    result = ns.count();
    sprintf(body, "%s,svID=%.17s smpCount=%d,IA=%d,IAQ=%d,IB=%d,IBQ=%d,IC=%d,ICQ=%d,IN=%d,INQ=%d,VA=%d,VAQ=%d,VB=%d,VBQ=%d,VC=%d,VCQ=%d,VN=%d,VNQ=%d %lu   \n", MEASURE,svph->svID,ntohs(svph->smp_count),ntohl(measure->ia),ntohl(measure->ia_q),ntohl(measure->ib),ntohl(measure->ib_q),ntohl(measure->ic),ntohl(measure->ic_q),ntohl(measure->in),ntohl(measure->in_q),ntohl(measure->va),ntohl(measure->va_q),ntohl(measure->vb),ntohl(measure->vb_q),ntohl(measure->vc),ntohl(measure->vc_q),ntohl(measure->vn),ntohl(measure->vn_q),result);
    sprintf(header,"POST /api/v2/write?org=%s&bucket=%s&precision=ns HTTP/1.1\r\nHost: influx:8086\r\nAuthorization:Token %s\r\nContent-Length: %ld\r\n\r\n", 
             ORG, BUCKET, TOKEN, strlen(body)); 
    write(sockfd, header, strlen(header));
    printf("Send to InfluxDB the data bytes=%lu \n->|%s|<-\n",strlen(body), body);
    ret = write(sockfd, body, strlen(body));
    printf("%d\n",ret);
    //printf("%s\n",errno);

    return;
}

